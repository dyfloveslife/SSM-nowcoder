# nowcoder 讨论平台

# 相关技术与开发环境
- Spring Boot
- Spring、Spring MVC、MyBatis
- Redis、MySQL、Kafka、Elasticsearch
- Spring Security、Spring Actuator
- Maven、Tomcat、Git

# 环境搭建与说明
- pom.xml
  - org.springframework.boot: 2.1.5.RELEASE
  - JDK version: 1.8
  - mysql-connector-java: 8.0.16
  - org.mybatis.spring.boot: 2.0.1

数据库使用 MySQL-8.0.15，数据库可视化软件 MySQL-workbench，数据源使用 HikariDataSource，并设置最大连接、最小连接以及超时时间等。

使用 Kaptcha 生成验证码，配置 MyBatis 属性，使之自动生成主键，并开启数据库字段名与 Bean 实体名相匹配。日志等级设置为 debug，以便可以查看具体执行的 sql 语句。

使用 logback 记录日志，Spring Email 发送邮件，便于后序的注册操作。

一般先根据表中的字段在 entity 中建立相应的实体类，然后在 DAO 层建立相应的 Mapper 接口，然后在 Mapper 中声明一些增删改查的方法，其次可以新建一个 Mapper 文件，在里面填入相应的 sql 语句。当然，也可以直接在 DAO 层的 Mapper 接口的方法上直接写 sql 语句。写完之后，在测试类中测试一下 sql 语句是否正确。在 service 层注入相应的 Mapper，最后在表现层处理相应的请求路径。

在登录页面提交的时候，需要在表单设置提交方式以及提交路径，每个框加上和 controller 一致的 name，这些是发送请求需要进行的设置。

如果有什么问题再回到该页面，对页面进行错误信息的展现，将原来的值使用 value 进行显示，然而是否显示需要根据样式进行动态展示的。

# 注册页面
使用模板复用顶部区域内的链接。通过点击顶部区域的链接，打开注册页面，然后进行相应的注册。

在注册的时候，需要通过表单提交数据，然后服务器检查账号是否已经存在，邮箱是否已经注册，没有的话执行注册，最后服务器发送激活邮件。

客户端在收到激活邮件后，点击链接即可激活邮箱。

# 会话管理
使用分布式部署的时候，为什么使用 session 会存在问题？

客户端在访问服务器的时候，会在不同的服务器上产生多个 session，这样会造成服务器之间得不到之前的 session。一种解决方式是可以设置 nginx 负载均衡的分配策略；另一种方式是黏性 session，对于同一个 ip，每次只能访问其中一个服务器，但这样的话不会产生负载均衡的效果；还有一种方式是同步session，即当某个服务器在产生 session 的时候，会在其它服务器上产生同样的 session，这样的话每个服务器都存放了同样的 session 数据，但这种方式会对服务器的性能产生影响，同时服务器之间会产生耦合，不会那么的独立。还有一种共享 session，即将所有的 session 数据存放在一台服务器中，然后其它的服务器在每次需要获取 session 的时候，直接从这台服务器获取即可，但是也同样存在问题，这台服务器要是挂了，那么所有的 session 数据也就没有了。现在主流的方式是让这些服务器共同访问数据库集群，并将 session 保存在数据库中。但是，由于一些关系型数据库大多是把数据存放在硬盘里，相对于内存，其访问速度稍微有些慢，所以可以将 session 存放在非关系型数据库中，如 Redis。

# 拦截器的设置
使用拦截器拦截浏览器的不同请求，根据不同的用户显示不同的网站功能。先定义一个拦截器，然后在配置类中进行配置，实现添加拦截器的方法。在 html 中进行相应的配置。

检查登录状态，避免用户在浏览器输入敏感路径造成的损失。

# 发布帖子
对于发布之前敏感词的过滤问题，采用前缀树实现。使用 AJAX 进行异步请求，从而实现在不刷新整个页面的情况下，更新页面部分数据。

# 事务管理
理解事务的特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。给“添加评论”模块添加事务。

# 处理异常

浏览器发送的请求首先会给表现层，然后再给业务层，最后再给数据层，层层调用。如果数据层出现了异常，则会抛给业务层，然后再抛给表现层。所以，这里对表现层进行统一的异常处理。

对于 Spring Boot 来说，可以将错误页面，如 404.html 放在 templates/error 下。

# 记录日志
假如在业务层需要记录日志，此时为了避免采用硬编码的方式对业务层进行修改，这里使用面向切面编程（AOP）的方式进行统一记录日志。AOP 可以用来实现权限检查、记录日志、事务管理等。

AOP 编程思想：
- target: 目标对象，即已经开发好的多个 bean；
- joinpoint: 切入点，即目标对象上有很多地方可以被织入代码，那些能够被织入代码的地方被称作连接点；
- aspect: 切面，即 AOP 处理代码的方式是将其编写在额外的组件里；
  - pointcut: 切点，即通过切点声明将代码织入到哪些对象的哪些位置；
  - advice: 通知，即声明切面组件处理逻辑的方式；
- waving: AOP 将 aspect 中的代码通过织入（waving）的方式织入到某些连接点（joinpoint）上。

具体的实现方式:
- AspectJ:
  - 编译期织入
- Spring AOP:
  - 运行期织入
  - 只支持方法类型
  - 代理方式
    - JDK 动态代理，在运行时创建接口的代理实例
    - CGLib 动态代理，在运行时创建子类的代理实例